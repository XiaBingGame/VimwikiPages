<html>
<head>
    <link rel="Stylesheet" type="text/css" href="../../../../style.css" />
    <title>thebiggestoneframe2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<body>
<div id="all">
<div id="header">
	<ul id="top-nav">
		<li>
			<a href="../index.html">首页</a>
		</li>
	</ul>
</div>
</div>
    <div class="content">
    
<div id="osgUtil::SceneView::cull()"><h2 id="osgUtil::SceneView::cull()" class="header"><a href="#osgUtil::SceneView::cull()">osgUtil::SceneView::cull()</a></h2></div>
<ul>
<li>
OSG 渲染后台的主体是场景视图(SceneView), 它实现了"树状结构"的管理方式, 以及多个专用于渲染工作的内部类

<li>
OSG 渲染后台的几个"重要角色"

<ul>
<li>
osgUtil::CullViisitor: "筛选访问器", 对每一个遇到的节点执行场景筛选的工作, 判断它是否会超出视截锥体范围, 过于渺小, 或者被遮挡节点(OccluderNode)挡住, 从而将无助益于场景浏览的物体筛选并剔除, 降低场景绘制的资源消耗.

<li>
osg::RenderInfo: "渲染信息"管理器, 负责保存和管理与场景绘制息息相关的几个重要数据. 当前场景的视景器, 当前场景对应的所有摄像机, 当前所有 OpenGL 渲染状态和顶点数据. 用于在场景筛选和渲染时为OSG的工作提供重要依据

<li>
osgUtil::StateGraph: "状态节点", 类似场景树的组节点(Group), 将 StateGraph 理解为 OSG 渲染后台的组节点. 以节点的渲染状态集(StateSet)为依据, 状态节点采用映射表 std::map 来组织它的子节点, 同一层次的子节点如果渲染状态相同, 则合并到同一个"状态节点"中.

<li>
osgUtil::RenderLeaf: "渲染叶", 我们可以把 RenderLeaf 理解为 OSG 渲染后台状态树的叶节点. 其绝非等同于场景树的 Geode 节点, "渲染叶"的工作主要是记录场景树中存在的各种 Drawable 对象(以及与之相关的投影矩阵, 模型视点矩阵等信息). 每个"状态节点(osgUtil::StateGraph)"中都包含了一个渲染叶的列表(StateGraph::_leaves), 不过只有最末端的"状态节点"会负责记录场景中的"渲染叶".

<li>
osgUtil::RenderStage: "渲染台". OSG 的渲染后台除了使用"状态树"来组织和优化节点的渲染状态之外, 还有另外一种用于场景实际渲染的组织结构, 我们称之为"渲染树", "渲染树"的根节点就是"渲染台"

<ul>
<li>
"摄像机渲染顺序"的功能, 通过 Camera::setRenderOrder 设置, PRE_RENDER 的摄像机在主相机之前执行渲染，可实现"纹理烘培(Render To Texture)"的功能, 见例子 osgprerender。POST_RENDER 的摄像机在主相机之后进行渲染, 可实现诸如 HUD 的效果。

<li>
slave cameras 主要是为了实现同一场景的分窗口以及分屏幕显示。(见例子 osgcamera)

<li>
对于 HUD显示, 简单鹰眼图等功能，则向场景图添加新的摄像机节点, 并设置与主摄像机不同的观察矩阵和投影矩阵。

</ul>
<li>
osgUtil::RenderBin: "渲染元", OSG 渲染树的分支节点，渲染树按照遍历的顺序，把"状态节点"和"渲染叶"记录到作为根节点的"渲染台(RenderStage)"当中(std::vector成员变量 RenderBin::_stateGraphList, RenderBin::_renderLeafList), 然后就可以执行场景的绘制工作. 注意的是 RenderStage 派生自 RenderBin.

<ul>
<li>
osg::StateSet::setRenderBinDetail 设置渲染顺序

<ul>
<li>
第一个参数为整数，小于0的渲染状态集将排列在前, 大于0的渲染状态集则排列在后.

<li>
第二个字符串参数: "RenderBin" 表示在渲染树中新建分支进行渲染, "DepthSortedBin" 表示新建分支, 并且所有要渲染的数据按照深度值降序进行排序.

<li>
注意当字符串参数不为 "RenderBin" 或 "DepthSortedBin" 时, 本函数的设置无效.
<pre c++>
// 默认渲染方式，渲染顺序为0，此时状态节点直接置入"渲染台"
stateSet-&gt;setRenderBinDetails(0, "");
// 渲染顺序 -1(先渲染)， 渲染树新建一个"渲染元"节点
stateSet-&gt;setRenderBinDetails(-1, "RenderBin");
// 渲染顺序 10， 渲染树新建一个"渲染元"节点, 并按深度值降序排序各元素.
stateSet-&gt;setRenderBinDetails(10, "DepthSortedBin");
</pre>

</ul>
<li>
osg::StateSet::setRenderingHint() 设置渲染的顺序, 参数可为枚举值 OPAQUE_BIN 或 TRANSPARENT_BIN
<pre c++>
state-&gt;setRenderingHint(OPAQUE_BIN);
// 等价于
state-&gt;setRenderBinDetails(0, "RenderBin")

state-&gt;setRenderingHint(TRANSPARENT_BIN);
// 等价于
state-&gt;setRenderBinDetails(0, "DepthSortedBin")
</pre>

</ul>
</ul>
<li>
举例

</ul>
<p>
<img src="http://www.xiabingdev.com/cloudimages/images/2021/05/02/08_node_relation.png" />
</p>
<ul>
<li>
"ss"加上数字代号来标识这些 StateSet 对象, "-" 表示空字串, "R" 表示 "RenderBin", "D" 表示 "DepthSortedBin"
<pre c++>
ss03-&gt;setRenderBinDetails(0, "");  // 这是默认的设置.
ss11-&gt;setRenderBinDetails(0, ""); 
ss13-&gt;setRenderBinDetails(-1, "RenderBin"); 
ss14-&gt;setRenderBinDetails(1, "RenderBin"); 
ss15-&gt;setRenderBinDetails(10, "DepthSortedBin"); 
ss16-&gt;setRenderBinDetails(10, "DepthSortedBin"); 
</pre>

<li>
OSG中所有的 drawable 几何体对象都会自动关联一个 StateSet 对象, 无论用户是否设置了.

<li>
OSG 生成相应的"状态树", 由"状态节点"(StateGraph)和"渲染叶"(RenderLeaf)所组成

</ul>
<p>
<img src="http://www.xiabingdev.com/cloudimages/images/2021/05/03/09_osgstatetree.png" />
</p>
<ul>
<li>
状态根节点 _rootState 和局部状态节点 _localState 由状态树自动生成, _localState 保护和维护一些渲染后台自动创建的渲染属性. 全局状态节点 _globalStateSet 的取值来自于主相机的 StateSet.

<li>
一个或多个渲染叶必然被一个状态树末端的节点(StateGraph)所拥有.

<li>
后台生成对应的"渲染树", 由一个 RenderStage 对象和多个 RenderBin 对象组成.

<li>
如不使用 setRenderBinDetails 设置 StateSet 的渲染细节, 则所有状态树中的末端节点都会按照遍历顺序保存到渲染树根节点(渲染台)中, 否则如下图

</ul>
<p>
<img src="http://www.xiabingdev.com/cloudimages/images/2021/05/03/09_render_tree.png" />
</p>
<ul>
<li>
根据渲染顺序的不同,渲染树生出了三个分支.

<li>
上面未设置渲染细节的状态节点直接由根节点(渲染台, RenderStage)负责维护.

<li>
一个渲染元中可以有一个或多个状态节点(或渲染叶), 一个状态节点(或渲染叶)只能置入一个渲染元中.

<li>
如果改变 s03 的渲染顺序,则结果如下
<pre c++>
ss03-&gt;setRenderBinDetails(1, "RenderBin");
</pre>

</ul>
<p>
<img src="http://www.xiabingdev.com/cloudimages/images/2021/05/03/10_morecomplex_rendertree.png" />
</p>
<ul>
<li>
由上两个渲染状态(StateSet)的渲染序号相同时,它们不一定放入同一个"渲染元"中.

<li>
见例子 osghangglide.

</ul>
<li>
归纳总结:

<ul>
<li>
osgUtil::StateGraph: 状态节点, 负责管理场景树中的一个渲染状态(StateSet)对象, 末端的 StateGraph 节点还负责维护一个"渲染叶"(RenderLeaf)的列表.

<li>
osgUtil::RenderLeaf: 状态树的叶节点(渲染叶), 负责管理和绘制场景树末端的一个几何体(Drawable)对象.

<li>
osgUtil::RenderStage: 渲染树的根节点(渲染台), 负责管理默认渲染顺序的所有末端 StateGraph 节点(附带"渲染叶"), 并保存了"前序渲染"(pre-render)和"后续渲染"(post-render)的渲染台指针的列表.

<li>
osgUtil::RenderBin: 渲染树的分支节点(渲染元), 负责管理自定义渲染顺序的末端 StateGraph 节点(附带"渲染叶"),渲染树的根节点和分支节点最多只能有"RenderBin" 和 "DepthSortedBin"两类子节点, 但可以根据不同的渲染序号衍生出多个子节点, 它们在渲染时将按照顺序号升序的次序执行绘制.

</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::SceneView::cull() 的工作 "><h3 id="osgUtil::SceneView::cull() 的工作 " class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::SceneView::cull() 的工作 ">osgUtil::SceneView::cull() 的工作 </a></h3></div>
<ul>
<li>
初始化 SceneView 的成员变量: 

<ul>
<li>
渲染信息(_renderInfo): 设置 osg::State

<li>
筛选访问器(_cullVisitor): CullVisitor::create()

<li>
状态树根节点(_stateGraph): osgUtil::StateGraph

<li>
渲染树根节点(_renderStage): osgUtil::RenderStage

<li>
局部渲染状态(_localStateSet, 见 SceneView::updateUniforms, 一些内设的 osg::Uniform 着色器变量 osg_FrameNumber, osg_FrameTime, osg_DeltaFrameTime, osg_SimulationTime, osg_ViewMatrix, osg_ViewMatrixInverse, 这些一致变量可在GLSL程序里获取).

</ul>
<li>
设置立体显示的选项, osg::DisplaySettings::LEFT_EYE/RIGHT_EYE, SceneView 的一些成员 computeLeftEyeProjection, computeLeftEyeView, computeRightEyeProjection, computeRightEyeView 等.

<li>
[核心函数]执行 SceneView::cullStage 函数

<li>
执行 CullVisitor::clampProjectionMatrix, 根据远/近平面的取值, 重新设定场景视图的投影矩阵. 由于远/近平面是由筛选访问器计算出来的,如果想设置自己的处理, 可以使用 setClampProjectionMatrixCallback 函数来设置 SceneView 的投影矩阵计算回调, 自己编写相关的处理函数.

</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::SceneView::cullState"><h3 id="osgUtil::SceneView::cullState" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::SceneView::cullState">osgUtil::SceneView::cullState</a></h3></div>
<ul>
<li>
该函数的主要工作:

<ul>
<li>
统计场景中的遮挡节点(OccluderNode), 使用 CollectOccluderVisitor 访问器遍历场景中的所有节点。
<pre c++>
for(unsigned int i = 0; i &lt; _camera-&gt;getNumChildren(); ++i)
	_camera-&gt;getChild(i)-&gt;accept(*_collectOccludersVisitor);
</pre>

<ul>
<li>
_camera 为 SceneView 的主摄像机， setSceneData() 函数会自动将场景根节点设置为各个主/从摄像机的子节点。

</ul>
<li>
设置筛选访问器(CullVisitor)所需的数据, 这些数据有筛选设置(CullSettings), 状态树根节点(StateGraph), 渲染树根节点(RenderStage)，渲染信息(RenderInfo)。

<li>
将"全局状态节点"和"局部状态节点"追加到状态树中。通过函数 CullVisitor::pushStateSet 和 CullVisitor::popStateSet.

<li>
筛选访问器遍历场景中的节点，筛选裁剪掉用户无法看到的对象。
<pre c++>
for(unsigned int childNo = 0; childNo &lt; _camera-&gt;getNumChildren(); ++childNo)
	_camera-&gt;getChild(childNo)-&gt;accept(*cullVisitor);
</pre>

<li>
执行 RenderStage::sort 和 StateGraph::prune 函数, 对筛选后的渲染树内容进行排序和精简(构建过程可能会剔除某些空节点)

<li>
计算出场景中所有动态对象(DYNAMIC)的数量，并将其保存到 SceneView 的成员变量 _dynamicObjectCount 中。

</ul>
</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::CullVisitor::pushStateSet()"><h3 id="osgUtil::CullVisitor::pushStateSet()" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::CullVisitor::pushStateSet()">osgUtil::CullVisitor::pushStateSet()</a></h3></div>
<ul>
<li>
pushStateSet() 和 popStateSet() 完成状态树和渲染树的构建. CullVisitor::apply 则根据不同的节点类型, 在不同的时机调用这两个函数.

<li>
pushStateSet() 的主要工作(传出 StateSet* ss 参数):

<ul>
<li>
状态树的构建. 判断传入的渲染状态 ss 是否已经存在于某个状态节点中，如果存在则将状态树的当前位置移动至该节点上，或者新建一个包含了 ss 的状态节点
<pre c++>
	_currentStateGraph = _currentStateGraph-&gt;find_or_insert(ss);
</pre>

<li>
渲染树的构建

<ul>
<li>
创建新的渲染树节点的三个条件

<ul>
<li>
渲染状态没有采用覆盖渲染细节的方式(OVERRID_RENDERBIN_DETAILS), 由 setRenderBinMode 函数设置.

<li>
setRenderBinDetail 设置渲染细节

<li>
渲染细节的字符串名称不为空("RenderBin"或"DepthSortedBin")

</ul>
<li>
满足上述条件后会转到指定的节点或新建一个渲染元(RenderBin::find_or_insert), 并使用堆栈记录上一次在渲染树中的位置.
<pre c++>
_renderBinStack.push_back(_currentRenderBin);
_currentRenderBin = _currentRenderBin-&gt;find_or_insert(ss-&gt;getBinNumber(), ss-&gt;getBinName());
</pre>

<li>
渲染树的构建过程中只生成空的渲染元(RenderBin)节点,向其中插入状态节点和渲染叶的任务将在后面的工作中完成.

</ul>
</ul>
<li>
popStateSet 的工作

<ol>
<li>
从堆栈中取出上一次渲染树中所处的渲染元节点, 并跳转到该位置.
<pre c++>
_currentRenderBin = _renderBinStack.back();
_renderBinStack.pop_back();
</pre>

<li>
状态树从当前位置跳转到其父节点
<pre c++>
_currentStateGraph = _currentStateGraph-&gt;_parent;
</pre>

</ol>
<li>
在筛选(CULL)过程中,我们判断某个节点(及其子树)应当被剔除掉时,只要跳过 pushStateSet 和 popStateSet 的步骤,直接返回,就不会在渲染时留下节点的任何蛛丝马迹.

</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)"><h3 id="osgUtil::CullVisitor::apply(Node&amp;)" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)">osgUtil::CullVisitor::apply(Node&amp;)</a></h3></div>
<ul>
<li>
NodeVisitor 的工作如下

</ul>
<p>
<img src="http://www.xiabingdev.com/cloudimages/images/2021/06/05/NodeVisitorWork.png" />
</p>

<div id="osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)-osgUtil::CullVisitor::apply(Transform&amp;)"><h4 id="osgUtil::CullVisitor::apply(Transform&amp;)" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)-osgUtil::CullVisitor::apply(Transform&amp;)">osgUtil::CullVisitor::apply(Transform&amp;)</a></h4></div>
<ul>
<li>
工作流程如下:

<ul>
<li>
isCulled() 判断某个节点是否应该被剔除

<ul>
<li>
最终执行 CullingSet::isCulled() 函数, 进行视锥体,细节筛选,遮挡筛选的工作.

<li>
Node::setCullingActive 设置某个节点始终不会被剔除

</ul>
<li>
pushCurrentMask() 函数, 记录当前视锥体筛选计算的结果(视锥体的哪几个面与节点的包围盒有交集), 并将这个结果压入堆栈,以便为下一次的计算提供方便. 具体可见代码 osg::Polytope::contains 系列函数

<li>
获取节点 StateSet, 如果存在则调用 pushStateSet, 进入相应状态树和渲染树的相应节点处.

<li>
计算 Transform 节点的位置姿态矩阵.

<ul>
<li>
通过 CullStack::createOrReuseMatrix 提供矩阵变换节点的存储矩阵.

<li>
使用 CullStack::pushModelViewMatrix 将计算得到的世界矩阵(Transform::computeLocalToWorldMatrix)压入堆栈,供后面的场景绘制和相应的用户回调使用.

</ul>
<li>
执行 CullVisitor::handle_cull_callbacks_and_traverse 函数, 处理用户自定义的 Node::CullCallback, 通过 traverse 将 visitor 对象传递给所有的子节点.

<li>
后面的操作都是前几步的"逆操作", "弹出"模型视图矩阵(popModelViewMatrix), 渲染状态(popStateSet)和筛选结果掩码(popCurrentMask)

</ul>
</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)-osgUtil::CullVisitor::apply(Geode&amp;)"><h4 id="osgUtil::CullVisitor::apply(Geode&amp;)" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)-osgUtil::CullVisitor::apply(Geode&amp;)">osgUtil::CullVisitor::apply(Geode&amp;)</a></h4></div>
<ul>
<li>
工作流程如下:

<ul>
<li>
isCulled(), 实现叶节点的筛选

<li>
pushStateSet(), 根据 Geode 的 StateSet 构建状态树和渲染树

<li>
handle_cull_callbacks_and_traverse(), 处理筛选回调并传递到子节点

<li>
遍历 geode 内的所有 Drawable, 执行 Drawable 的筛选, 以及 Drawable 自定义的 Cull callback, 这里 osg 使用 isCulled() 和 CullVisitor::updateCalculatedNearFar() 函数执行 Drawable 的筛选工作.

<li>
pushStateSet(), 根据 Drawable 的 StateSet 构建状态树和渲染树

<li>
CullVisitor::addDrawableAndDepth(), 将几何体对象及其深度值置入状态树和渲染树, 所有 drawable 对象添加到当前状态节点 _currentStateGraph(StateGraph::addLeaf) 和 当前渲染元 _currentRenderBin(RenderBin::addStateGraph) 上, 为状态树和渲染树添加了实质性的可绘制内容.

<li>
执行多次 popStateSet, 将 _currentStateGraph 和 _currentRenderBin 跳回到原先的位置.

</ul>
</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)-osgUtil::CullVisitor::apply(Camera&amp;)"><h4 id="osgUtil::CullVisitor::apply(Camera&amp;)" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::CullVisitor::apply(Node&amp;)-osgUtil::CullVisitor::apply(Camera&amp;)">osgUtil::CullVisitor::apply(Camera&amp;)</a></h4></div>
<ul>
<li>
当场景树中出现一个摄像机节点时, 它以下的场景子树将按照这个摄像机的筛选,视口,观察矩阵,投影矩阵设置进行显示. 我们也可以使用此摄像机指向另一个图形设备(窗口)

<li>
工作流程:

<ul>
<li>
加载该相机的筛选设置(setCullSetting 设置的内容), 并保存之前的设置

<li>
加载当前相机 Camera 的遍历掩码(setTraversalMask), 这里的遍历掩码是用户通过 CullSettings::setCullMask 函数设置的. 节点掩码 (setNodeMask) 与遍历掩码"与"操作之后为0的节点不会在当前相机中显示.

<li>
得到摄像机的视口,投影矩阵,模型视图矩阵,依次压入堆栈中(pushViewport, pushProjectionMatrix, pushModelViewMatrix)

<li>
针对采用 PRE_RENDER 和 POST_RENDER 方式的摄像机新建一个"渲染台"(RenderStage), 并使用相机的相关参数来初始化该渲染台.

<ul>
<li>
Camera 节点的子树将全部追加到新建的"渲染台"当中. 使用 addPreRenderStage 或 addPostRenderStage 函数将新建的渲染台追加到当前 RenderStage 对象的相应列表中.

<li>
对于 NESTED_RENDER 的相机 Camera(默认设置), 不存在前序渲染/后序渲染这一说法, 直接执行 handle_cull_callbacks_and_traverse 函数, 继续向子节点遍历.

</ul>
<li>
从堆栈中依次弹出模型视图矩阵,投影矩阵,相机视口的临时计算量, 恢复遍历掩码和筛选设置. 回到上级相机的控制当中, 继续场景图形的遍历工作

</ul>
</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::RenderStage::sort()"><h3 id="osgUtil::RenderStage::sort()" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::RenderStage::sort()">osgUtil::RenderStage::sort()</a></h3></div>
<ul>
<li>
在状态树和渲染树构建完毕之后, 依次执行 RenderStage::sort 和 StateGraph::prune, 完成对渲染树中数据的排序和优化.

<li>
RenderStage::sort 依次执行前序渲染台(RenderStage::_preRenderList), 当前渲染台, 后序渲染台(RenderStage::_postRenderList)

<li>
渲染树及其各个分支中数据的排序工作事实上是通过 RenderBin::sortImplementation() 函数实现的. 根节点渲染台调用 RenderBin::setSortCallback 可以实现自定义的渲染树排序动作.

<li>
排序的对象为渲染树中各个渲染元(RenderBin)中保存的状态节点(StateGraph)或渲染叶(RenderLeaf), 渲染元之间不需要进行排序.

<li>
OSG 事实上仅针对 "DepthSortedBin" 渲染元中的各个渲染叶(RenderLeaf)进行排序, 排序函数为 RenderBin::sortBackToFront, 按照深度值降序的原则使用 std::sort 执行所有元素的排序动作. 这里的深度值是在 CullVisitor::apply(Geode&amp;)函数中计算出来.

<li>
排序方法除了 SORT_BY_STATE(不进行排序) 和 SORT_BACK_TO_FRONT 之外, RenderBin::setSortMode 还可以指定另外两种排序方式:

<ul>
<li>
SORT_BY_STATE_THEN_FRONT_TO_BACK: 获取当前渲染元所保存的所有头状态节点(StateGraph), 将每个节点中所有的渲染叶对象按深度升序排序,然后将各个状态节点按最小深度值升序排序(保存有深度值最小的渲染叶的节点排在最前)

<li>
SORT_FRONT_TO_BACK: 采用深度值升序的原则执行所有元素的排序

</ul>
<li>
StateGraph::prune() 函数的主要工作是查找状态树(StateGraph)中有没有无效的状态节点, 如有则将它们删除.

</ul>

<div id="osgUtil::SceneView::cull()-osgUtil::SceneView::cullStage()"><h3 id="osgUtil::SceneView::cullStage()" class="header"><a href="#osgUtil::SceneView::cull()-osgUtil::SceneView::cullStage()">osgUtil::SceneView::cullStage()</a></h3></div>
<ul>
<li>
场景筛选的最后一步是统计动态对象(DYNAMIC)的数量, 保存在 SceneView::_dynamicObjectCount 中, 供线程同步时使用.

<li>
负责统计的函数为 RenderBin::computeNumberOfDynamicRenderLeaves, 负责统计所有 RenderLeaf::_dynamic 设置为 true 的渲染叶的数目.

</ul>

<div id="osgUtil::SceneView::draw()"><h2 id="osgUtil::SceneView::draw()" class="header"><a href="#osgUtil::SceneView::draw()">osgUtil::SceneView::draw()</a></h2></div>
<ul>
<li>
进行场景的绘制工作

<li>
第一个工作为初始化 osg::State 类的 GL 库函数地址, State::initializeExtensionProcs

<li>
查看用户是否设置了场景视图初始化访问器(SceneView::setInitVisitor), 如设置, 则 draw 函数第一次执行时使用该访问器遍历场景树.

<li>
从场景和内存中删除所有已经标记为要删除的节点或 Drawable 对象, flushDeletedGLObjects() 函数, 由于可能多个线程同时申请使用 flushDeletedGLObjects 删除对象, 通过变量 SceneView::_requiresFlush 来控制.

<li>
场景绘制的核心工作:

<ul>
<li>
设置渲染台(RenderStage)的读/写缓存(GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_AUX 辅助缓存). 通过 setDrawBuffer 和 setReadBuffer 函数来设置.

<li>
确保颜色掩码的每个颜色通道都是被激活的(osg::ColorMask)

<li>
执行"前序渲染"渲染台的绘制(RenderStage::drawPreRenderStages)

<li>
执行当前渲染台(即渲染树的根节点)的绘制(RenderStage::draw)

</ul>
<li>
恢复所有的 OpenGL 状态(State::popAllStateSets()), 判断是否在绘制过程中出现 OpenGL 绘制命令错误, 并将错误信息打印出来.

</ul>

<div id="osgUtil::SceneView::draw()-osgUtil::RenderStage::draw()"><h3 id="osgUtil::RenderStage::draw()" class="header"><a href="#osgUtil::SceneView::draw()-osgUtil::RenderStage::draw()">osgUtil::RenderStage::draw()</a></h3></div>
<ul>
<li>
执行流程:

<ul>
<li>
执行相机的初始化回调(Camera::setInitialDrawCallback)

<li>
运行相机的设置(RenderStage::runCameraSetUp)

<li>
检查当前的图形设备指针(GraphicsContext), 判断正在运行的图形设备与渲染台所记录的当前设备(RenderStage::_graphicsContext)是否一致, 如果不同则转换到该设备上, 避免指定渲染上下文时出错.

<li>
执行相机的绘制前回调(Camera::setPreDrawCallback)

<li>
实际的绘制工作. 多线程模式中, 向图形设备线程(GraphicsContext::getGraphicsThread)添加一个新的Operation对象 DrawInnerOperation, 在绘制结束后才能执行线程的其他Operation对象.

<li>
对于单线程模式, 直接执行 RenderStage::drawInner() 函数.

<li>
如果设置了相机的RTT方式,则执行 RenderStage::copyTexture 函数.

<li>
执行相机的绘制后回调(Camera::setPostDrawCallback)

<li>
对于单线程, 使用 glFlush() 刷新所有 OpenGL 管道中的命令. 并释放当前渲染上下文(GraphicsContext::releaseContext)

<li>
执行"后序渲染"渲染台的绘制(RenderStage::drawPostRenderStages)

<li>
执行相机的绘制结束回调(Camera::setFinalDrawCallback)

<ul>
<li>
可以选择在某个回调中执行 OpenGL 函数(初始化与结束回调时不能执行)或自定义代码.

</ul>
<li>
设置渲染目标和绑定纹理
<pre c++>
osg::Texture2D* texture = new osg::Texture2D;
camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER);
camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture);
</pre>

<li>
Camera::Attachment 结构体保存绑定到相机的实际纹理或图片. RenderStage::runCameraSetUp 则反复遍历名为 Camera::BufferAttachmentMap 的映射表, 检索并设置那些与颜色缓存(COLOR_BUFFER), 深度缓存(DEPTH_BUFFER)等等相对应的 Attachment 对象.

<li>
RenderStage::copyTexture: 负责针对 FRAME_BUFFER 渲染目标, 拷贝场景图像到 Attachment 对象中.

</ul>
</ul>

<div id="osgUtil::SceneView::draw()-osgUtil::RenderStage::drawInner()"><h3 id="osgUtil::RenderStage::drawInner()" class="header"><a href="#osgUtil::SceneView::draw()-osgUtil::RenderStage::drawInner()">osgUtil::RenderStage::drawInner()</a></h3></div>
<ul>
<li>
FBO 对象的初始化

<ul>
<li>
FBOExtensions::isSupported 和 FrameBufferObject::hasMultipleRenderingTargets 函数来判断显示是否支持 FBO 以及 MRT(多重渲染目标) 扩展, 并使用 FrameBufferObject::apply 来调用实际的 FBO 执行函数. OpenGL 为多重渲染目标的支持提供了多大十六个颜色缓存, OSG 中表示为 Camera::COLOR_BUFFERi, i 的取值范围为 0 到 15.

</ul>
<li>
如果没有启用 FBO 支持或者没有使用 MRT, 作为渲染树根节点的渲染台(RenderStage)负责使用 glDrawBuffer 和 glReadBuffer 分别设置绘制缓存和读取缓存(对于用户来说,通过Camera的setDrawBuffer和setReadBuffer实现). 如两个缓存均为 GL_BACK 时, 场景的绘制将在后台缓存完成, 用 SwapBuffer 动作交换前后双缓存的数据, 该特性为场景摄像机默认设置(指定 GraphicsContext::Traits::doubleBuffer),

<li>
RenderBin::draw 函数. 负责从根节点开始遍历渲染树, 并执行各个渲染叶(RenderLeaf)以及上层状态节点(StateGraph)所包含的内容.

<ul>
<li>
完成场景的实际绘制工作之后, OSG 将检测并显示出场景绘制当中遇到的错误, 如"Warning: detected OpenGL error... after RenderBin::draw()" 的字样, 通常是显卡对 OpenGL 高版本的某些函数或枚举值不支持而造成的

</ul>
<li>
FBO 有关的操作, 包括使用 glBlitFramebufferEXT 进行解算, 将结果复制到关联的纹理以及图像对象中, 并结束 FBO 的调用.

<li>
Camera 设置渲染顺序为 PRE_RENDER 可以保证该相机在主场景之前执行绘制(创建了一个"前序渲染台"),存入 RenderStage::_preRenderList 列表, 从而实现"渲染到纹理"的效果, 见 osgprerender 例子

</ul>

<div id="osgUtil::SceneView::draw()-osgUtil::RenderStage::drawInner()-osgUtil::RenderBin::drawImplementation()"><h4 id="osgUtil::RenderBin::drawImplementation()" class="header"><a href="#osgUtil::SceneView::draw()-osgUtil::RenderStage::drawInner()-osgUtil::RenderBin::drawImplementation()">osgUtil::RenderBin::drawImplementation()</a></h4></div>
<ul>
<li>
RenderBin::draw 函数的工作就是调用 RenderBin::drawImplementation 函数. 用户可以用自定义的绘制回调(RenderBin::setDrawCallback) 代替 drawImplementation 来完成这一绘制工作.

<li>
osg::State 的几点重要功能:

<ul>
<li>
保存 OpenGL 的所有状态, 模式, 属性参数, 顶点和索引数据

<li>
提供对 OpenGL 状态堆栈的处理机制, 对即将进入渲染管线的数据进行优化

<ul>
<li>
对于 OpenGL 渲染状态堆栈的处理， 实际上就是对于 OSG 状态树 (StateGraph) 的遍历处理。

<li>
OpenGL 各种 Mode 的开关(glEnable/glDisable)实际上是通过 State::applyMode 函数完成。

<li>
各种顶点(位置,法线,颜色等)数组和索引数组的设置(对应于OpenGL的glVertexPointer,glNormalPointer等), 通过State的setVertexPointer等函数实现的.

<li>
State类的 applyAttribute 函数, 会调用不同渲染属性的 StateAttribute::apply(State&amp;) 函数.

</ul>
<li>
允许用户直接查询各种 OpenGL 状态的当前值

</ul>
<li>
osg::State 是 OSG 与 OpenGL 的主要接口; 场景状态树的遍历者和整合者, 也是各种渲染状态以及顶点值的处理途径.

<li>
渲染树的叶节点 RenderLeaf 将 Geometry 对象的顶点坐标和索引信息数据传递给 State 对象

<li>
Drawable 对象通过 Drawable::draw 函数进行绘制, Getmetry 在绘制过程中, 将自己记录的数据信息传递给 State 对象, 由 State 对象完成顶点的载入和处理.

<li>
渲染树的作用, 抽取每个渲染树节点(RenderBin)中的渲染叶(RenderLeaf)对象, 由 osg::State 整合这些渲染叶在状态树中继承的全部渲染状态, 并将几何体数据传递给 OpenGL 管线, 完成绘制的工作.

</ul>
<p>
<img src="http://www.xiabingdev.com/cloudimages/images/2021/06/19/drawrelation.png" />
</p>
<ul>
<li>
Drawable 几何体对象的具体实现位于 drawImplementation 函数(事实上是通过 draw 函数间接调用); 而渲染属性的具体实现函数为 StateAttribute::apply(State&amp;), 所有的渲染属性都重写了该函数, 以实现自己的功能.

<li>
OSG 的渲染流程:

<ul>
<li>
渲染树的作用是遍历各个渲染元(RenderBin), 并按照指定的顺序执行其中各个渲染叶的渲染函数(RenderLeaf::render)

<li>
状态树保存了从根节点到当前渲染叶的路径, 遍历这条路径并收集所有的渲染属性数据(StateGraph/moveStateGraph),即可获得当前渲染叶渲染所需的所有OpenGL状态数据

<li>
渲染叶的渲染函数向osg::State传递渲染状态数据,由渲染属性类StateAttribute本身完成参数在OpenGL的注册和加载工作.同时渲染叶调用几何体(Drawable)的绘制函数,加载顶点和索引数据.

</ul>
<li>
OSG场景绘制的执行流程如下:

<ul>
<li>
判断当前 RenderBin 在渲染树中的位置, 并在此位置临时插入一个新的渲染状态 RenderBin::_stateset. 对于透明渲染元(TRANSPARENT_BIN), 此渲染状态会自动设置一个 alpha 属性(osg::AlphaFunc), 以便自动剔除绘制结果中颜色 Alpha 分量为 0 的像素.

<li>
遍历所有的子渲染元(RenderBin::_bins), 其中渲染顺序号小于 0 的渲染元将在这里执行它们的 RenderBin::draw 函数, 由于 draw 函数内部调用了 drawImplementation, 所以产生了递归调用, 回到第一步, 直至渲染树遍历至末端节点, StateSet::setRenderBinDetails 函数可设置渲染顺序号.

<li>
遍历当前 RenderBin 所保存的所有渲染叶(RenderBin::_renderLeafList), 执行 RenderLeaf::render 函数, 实现场景的绘制. 通常只有被设置为"DepthSortedBin"的渲染元会选择保存渲染叶而非状态节点(StateGraph).

<li>
遍历当前 RenderBin 所保存的所有状态节点(RenderBin::_stateGraphList), 获取其中保存的 RenderLeaf 对象(StateGraph::_leaves), 并执行其 render 函数

<li>
遍历所有的子渲染元(RenderBin::_bins), 其中渲染顺序号大于0的渲染元此时才执行它们的RenderBin::draw函数.

</ul>
<li>
由此可见, 由于递归, 渲染由下往上渲染. 首先被绘制的是顺序小于0的末端RenderBin节点,其次则依次是顺序号等于0的末端节点,大于0的末端节点,小于0的倒数第二级节点......,而作为渲染树根节点的RenderStage中保存的数据将最后被渲染.

<li>
渲染树中的同一层顺序号小于0(或大于0)的渲染元不止一个,则会按照顺序号从小到大的顺序依次被渲染.

<li>
渲染树同一层不可能存在渲染顺序号相同的渲染元, 因为 setRenderBinDetails 设置相同数字参量的 StateSet 对象被构建成状态节点(StateGraph)之后,将插入到同一个 RenderBin 中.

</ul>

<div id="osgUtil::SceneView::draw()-osgUtil::RenderStage::drawInner()-osgUtil::RenderLeaf::render()"><h4 id="osgUtil::RenderLeaf::render()" class="header"><a href="#osgUtil::SceneView::draw()-osgUtil::RenderStage::drawInner()-osgUtil::RenderLeaf::render()">osgUtil::RenderLeaf::render()</a></h4></div>
<ul>
<li>
RenderLeaf 是 OSG 渲染后台中几何体(Drawable)对象的唯一管理者. render 函数主要负责获取之前保存的 Drawable 指针, 投影矩阵, 模型视图矩阵, 深度值等信息(CullVisitor::addDrawableAndDepth函数完成传递这些信息). 将这些信息传递给 State 类, 并执行 Drawable::draw 函数

<li>
工作流程如下:

<ul>
<li>
State::applyProjectionMatrix 传递投影矩阵

<li>
State::applyModelViewMatrix 传递模型视图矩阵

<li>
如果正在渲染的渲染叶和之前处理的渲染叶父节点不同, 则遍历状态树中相应的路径, 更新 State 状态机中保存的渲染状态数据(std::map类型, 分别名为 _modeMap 和 _attributeMap), 更新状态的函数为 StateGraph::moveStateGraph, 其清除上一次使用的各种渲染状态, 再沿着状态树中的路径, 依次添加当前渲染叶所需要的数据, 最后执行函数 State::apply(const State*), 由 OSG 状态机处理并执行相应的 OpenGL 指令.

<li>
如果当前渲染叶和上一次处理的渲染叶有相同的父节点(StateGraph对象), 则不改变传入 State 状态机的状态数据, 直接执行 State::apply 函数.

<li>
执行渲染叶所保存的 Drawable 对象的 draw 函数, 完成几何体的绘制. 此时 Geometry(实际上是Drawable::drawImplementation)向 State 传递顶点和索引数据, 而后又 State 完成几何数据的绘制.

</ul>
</ul>

<div id="osgUtil::SceneView::draw()-osg::State::apply(const StateSet*)"><h3 id="osg::State::apply(const StateSet*)" class="header"><a href="#osgUtil::SceneView::draw()-osg::State::apply(const StateSet*)">osg::State::apply(const StateSet*)</a></h3></div>
<ul>
<li>
该函数的工作流程:

<ul>
<li>
State::applyModelList 函数, 接受渲染状态中的模式数据(StateSet::setMode 设置的数据), 通过 applyMode 函数设置, 实际的执行代码如下:
<pre c++>
if (enabled) glEnable(mode); 
else glDisable(mode);
</pre>

<li>
State::applyAttributeList 函数, 接受渲染状态中的属性数据(StateAttribute 的派生类对象, 使用 StateSet::setAttribute 设置), 并通过 applyAttribute 函数予以执行, 实际的执行代码
<pre c++>
attribute-&gt;apply(*this);
</pre>

<ul>
<li>
attribute 为 StateAttribute 对象, this 为 State 类对象.

<li>
如果想要自己写一个新的渲染属性类(如同时完成雾效和图像融合的工作),只要将虚函数StateAttribute::apply(State&amp;)重写就可以实现它与OSG渲染后台的接口.

<li>
State 类会保存两个映射表 _modeMap 和 _attributeMap 用于上面的工作

</ul>
<li>
以类似的方式处理纹理相关的渲染树性和模式. 之所以纹理相关的属性需要分开设置, 是因为需要设置多个纹理单元的属性, 每个纹理单元的属性有不同.

<li>
State::applyUniformList 将着色器所使用的 Uniform 变量传递下去(事实上是传递给OSG内部的GLSL预编译器 Program::PreContextProgram 处理了), 这是实现 GLSL 与 OSG 系统交互的重要途径.

</ul>
</ul>
<p>
<img src="http://www.xiabingdev.com/cloudimages/images/2021/06/19/renderbackend.png" />
</p>

    </div>
</body>
</html>
